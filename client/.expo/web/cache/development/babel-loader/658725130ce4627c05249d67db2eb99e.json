{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport * as React from 'react';\nimport * as Utils from \"./WebCameraUtils\";\nimport { FacingModeToCameraType } from \"./WebConstants\";\nvar VALID_SETTINGS_KEYS = ['autoFocus', 'flashMode', 'exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'whiteBalance', 'zoom'];\n\nfunction useLoadedVideo(video, onLoaded) {\n  React.useEffect(function () {\n    if (video) {\n      video.addEventListener('loadedmetadata', function () {\n        requestAnimationFrame(function () {\n          onLoaded();\n        });\n      });\n    }\n  }, [video]);\n}\n\nexport function useWebCameraStream(video, preferredType, settings, _ref) {\n  var onCameraReady = _ref.onCameraReady,\n      onMountError = _ref.onMountError;\n  var isStartingCamera = React.useRef(false);\n  var activeStreams = React.useRef([]);\n  var capabilities = React.useRef({\n    autoFocus: 'continuous',\n    flashMode: 'off',\n    whiteBalance: 'continuous',\n    zoom: 1\n  });\n\n  var _React$useState = React.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      stream = _React$useState2[0],\n      setStream = _React$useState2[1];\n\n  var mediaTrackSettings = React.useMemo(function () {\n    return stream ? stream.getTracks()[0].getSettings() : null;\n  }, [stream]);\n  var type = React.useMemo(function () {\n    if (!mediaTrackSettings) {\n      return null;\n    }\n\n    var _mediaTrackSettings$f = mediaTrackSettings.facingMode,\n        facingMode = _mediaTrackSettings$f === void 0 ? 'user' : _mediaTrackSettings$f;\n    return FacingModeToCameraType[facingMode];\n  }, [mediaTrackSettings]);\n  var getStreamDeviceAsync = React.useCallback(_asyncToGenerator(function* () {\n    try {\n      return yield Utils.getPreferredStreamDevice(preferredType);\n    } catch (nativeEvent) {\n      if (__DEV__) {\n        console.warn(\"Error requesting UserMedia for type \\\"\" + preferredType + \"\\\":\", nativeEvent);\n      }\n\n      if (onMountError) {\n        onMountError({\n          nativeEvent: nativeEvent\n        });\n      }\n\n      return null;\n    }\n  }), [preferredType, onMountError]);\n  var resumeAsync = React.useCallback(_asyncToGenerator(function* () {\n    var nextStream = yield getStreamDeviceAsync();\n\n    if (Utils.compareStreams(nextStream, stream)) {\n      return false;\n    }\n\n    if (!activeStreams.current.some(function (value) {\n      return value.id === (nextStream == null ? void 0 : nextStream.id);\n    })) {\n      activeStreams.current.push(nextStream);\n    }\n\n    setStream(nextStream);\n\n    if (onCameraReady) {\n      onCameraReady();\n    }\n\n    return false;\n  }), [getStreamDeviceAsync, setStream, onCameraReady, stream, activeStreams.current]);\n  React.useEffect(function () {\n    if (isStartingCamera.current) {\n      return;\n    }\n\n    isStartingCamera.current = true;\n    resumeAsync().then(function (isStarting) {\n      isStartingCamera.current = isStarting;\n    }).catch(function () {\n      isStartingCamera.current = false;\n    });\n  }, [preferredType]);\n  React.useEffect(function () {\n    var changes = {};\n\n    for (var key of Object.keys(settings)) {\n      if (!VALID_SETTINGS_KEYS.includes(key)) {\n        continue;\n      }\n\n      var nextValue = settings[key];\n\n      if (nextValue !== capabilities.current[key]) {\n        changes[key] = nextValue;\n      }\n    }\n\n    var hasChanges = !!Object.keys(changes).length;\n\n    var nextWebCameraSettings = _objectSpread(_objectSpread({}, capabilities.current), changes);\n\n    if (hasChanges) {\n      Utils.syncTrackCapabilities(preferredType, stream, changes);\n    }\n\n    capabilities.current = nextWebCameraSettings;\n  }, [settings.autoFocus, settings.flashMode, settings.exposureCompensation, settings.colorTemperature, settings.iso, settings.brightness, settings.contrast, settings.saturation, settings.sharpness, settings.focusDistance, settings.whiteBalance, settings.zoom]);\n  React.useEffect(function () {\n    if (!video.current) {\n      return;\n    }\n\n    Utils.setVideoSource(video.current, stream);\n  }, [video.current, stream]);\n  React.useEffect(function () {\n    return function () {\n      for (var _stream of activeStreams.current) {\n        Utils.stopMediaStream(_stream);\n      }\n\n      if (video.current) {\n        Utils.setVideoSource(video.current, stream);\n      }\n    };\n  }, []);\n  useLoadedVideo(video.current, function () {\n    Utils.syncTrackCapabilities(preferredType, stream, capabilities.current);\n  });\n  return {\n    type: type,\n    mediaTrackSettings: mediaTrackSettings\n  };\n}","map":{"version":3,"mappings":"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","names":["React","Utils","FacingModeToCameraType","VALID_SETTINGS_KEYS","useLoadedVideo","video","onLoaded","useEffect","addEventListener","requestAnimationFrame","useWebCameraStream","preferredType","settings","onCameraReady","onMountError","isStartingCamera","useRef","activeStreams","capabilities","autoFocus","flashMode","whiteBalance","zoom","useState","stream","setStream","mediaTrackSettings","useMemo","getTracks","getSettings","type","facingMode","getStreamDeviceAsync","useCallback","getPreferredStreamDevice","nativeEvent","__DEV__","console","warn","resumeAsync","nextStream","compareStreams","current","some","value","id","push","then","isStarting","catch","changes","key","Object","keys","includes","nextValue","hasChanges","length","nextWebCameraSettings","syncTrackCapabilities","exposureCompensation","colorTemperature","iso","brightness","contrast","saturation","sharpness","focusDistance","setVideoSource","stopMediaStream"],"sourceRoot":"","sources":["../src/useWebCameraStream.ts"],"sourcesContent":["/* eslint-env browser */\nimport * as React from 'react';\n\nimport {\n  CameraReadyListener,\n  CameraType,\n  MountErrorListener,\n  WebCameraSettings,\n} from './Camera.types';\nimport * as Utils from './WebCameraUtils';\nimport { FacingModeToCameraType } from './WebConstants';\n\nconst VALID_SETTINGS_KEYS = [\n  'autoFocus',\n  'flashMode',\n  'exposureCompensation',\n  'colorTemperature',\n  'iso',\n  'brightness',\n  'contrast',\n  'saturation',\n  'sharpness',\n  'focusDistance',\n  'whiteBalance',\n  'zoom',\n];\n\nfunction useLoadedVideo(video: HTMLVideoElement | null, onLoaded: () => void) {\n  React.useEffect(() => {\n    if (video) {\n      video.addEventListener('loadedmetadata', () => {\n        // without this async block the constraints aren't properly applied to the camera,\n        // this means that if you were to turn on the torch and swap to the front camera,\n        // then swap back to the rear camera the torch setting wouldn't be applied.\n        requestAnimationFrame(() => {\n          onLoaded();\n        });\n      });\n    }\n  }, [video]);\n}\n\nexport function useWebCameraStream(\n  video: React.MutableRefObject<HTMLVideoElement | null>,\n  preferredType: CameraType,\n  settings: Record<string, any>,\n  {\n    onCameraReady,\n    onMountError,\n  }: { onCameraReady?: CameraReadyListener; onMountError?: MountErrorListener }\n): {\n  type: CameraType | null;\n  mediaTrackSettings: MediaTrackSettings | null;\n} {\n  const isStartingCamera = React.useRef<boolean | null>(false);\n  const activeStreams = React.useRef<MediaStream[]>([]);\n  const capabilities = React.useRef<WebCameraSettings>({\n    autoFocus: 'continuous',\n    flashMode: 'off',\n    whiteBalance: 'continuous',\n    zoom: 1,\n  });\n  const [stream, setStream] = React.useState<MediaStream | null>(null);\n\n  const mediaTrackSettings = React.useMemo(() => {\n    return stream ? stream.getTracks()[0].getSettings() : null;\n  }, [stream]);\n\n  // The actual camera type - this can be different from the incoming camera type.\n  const type = React.useMemo(() => {\n    if (!mediaTrackSettings) {\n      return null;\n    }\n    // On desktop no value will be returned, in this case we should assume the cameraType is 'front'\n    const { facingMode = 'user' } = mediaTrackSettings;\n    return FacingModeToCameraType[facingMode];\n  }, [mediaTrackSettings]);\n\n  const getStreamDeviceAsync = React.useCallback(async (): Promise<MediaStream | null> => {\n    try {\n      return await Utils.getPreferredStreamDevice(preferredType);\n    } catch (nativeEvent) {\n      if (__DEV__) {\n        console.warn(`Error requesting UserMedia for type \"${preferredType}\":`, nativeEvent);\n      }\n      if (onMountError) {\n        onMountError({ nativeEvent });\n      }\n      return null;\n    }\n  }, [preferredType, onMountError]);\n\n  const resumeAsync = React.useCallback(async (): Promise<boolean> => {\n    const nextStream = await getStreamDeviceAsync();\n    if (Utils.compareStreams(nextStream, stream)) {\n      // Do nothing if the streams are the same.\n      // This happens when the device only supports one camera (i.e. desktop) and the mode was toggled between front/back while already active.\n      // Without this check there is a screen flash while the video switches.\n      return false;\n    }\n\n    // Save a history of all active streams (usually 2+) so we can close them later.\n    // Keeping them open makes swapping camera types much faster.\n    if (!activeStreams.current.some((value) => value.id === nextStream?.id)) {\n      activeStreams.current.push(nextStream!);\n    }\n\n    // Set the new stream -> update the video, settings, and actual camera type.\n    setStream(nextStream);\n    if (onCameraReady) {\n      onCameraReady();\n    }\n    return false;\n  }, [getStreamDeviceAsync, setStream, onCameraReady, stream, activeStreams.current]);\n\n  React.useEffect(() => {\n    // Restart the camera and guard concurrent actions.\n    if (isStartingCamera.current) {\n      return;\n    }\n    isStartingCamera.current = true;\n\n    resumeAsync()\n      .then((isStarting) => {\n        isStartingCamera.current = isStarting;\n      })\n      .catch(() => {\n        // ensure the camera can be started again.\n        isStartingCamera.current = false;\n      });\n  }, [preferredType]);\n\n  // Update the native camera with any custom capabilities.\n  React.useEffect(() => {\n    const changes: WebCameraSettings = {};\n\n    for (const key of Object.keys(settings)) {\n      if (!VALID_SETTINGS_KEYS.includes(key)) {\n        continue;\n      }\n      const nextValue = settings[key];\n      if (nextValue !== capabilities.current[key]) {\n        changes[key] = nextValue;\n      }\n    }\n\n    // Only update the native camera if changes were found\n    const hasChanges = !!Object.keys(changes).length;\n\n    const nextWebCameraSettings = { ...capabilities.current, ...changes };\n    if (hasChanges) {\n      Utils.syncTrackCapabilities(preferredType, stream, changes);\n    }\n\n    capabilities.current = nextWebCameraSettings;\n  }, [\n    settings.autoFocus,\n    settings.flashMode,\n    settings.exposureCompensation,\n    settings.colorTemperature,\n    settings.iso,\n    settings.brightness,\n    settings.contrast,\n    settings.saturation,\n    settings.sharpness,\n    settings.focusDistance,\n    settings.whiteBalance,\n    settings.zoom,\n  ]);\n\n  React.useEffect(() => {\n    // set or unset the video source.\n    if (!video.current) {\n      return;\n    }\n    Utils.setVideoSource(video.current, stream);\n  }, [video.current, stream]);\n\n  React.useEffect(() => {\n    return () => {\n      // Clean up on dismount, this is important for making sure the camera light goes off when the component is removed.\n      for (const stream of activeStreams.current) {\n        // Close all open streams.\n        Utils.stopMediaStream(stream);\n      }\n      if (video.current) {\n        // Invalidate the video source.\n        Utils.setVideoSource(video.current, stream);\n      }\n    };\n  }, []);\n\n  // Update props when the video loads.\n  useLoadedVideo(video.current, () => {\n    Utils.syncTrackCapabilities(preferredType, stream, capabilities.current);\n  });\n\n  return {\n    type,\n    mediaTrackSettings,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}