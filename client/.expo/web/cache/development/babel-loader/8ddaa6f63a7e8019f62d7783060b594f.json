{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { Platform } from 'expo-modules-core';\nexport var userMediaRequested = false;\nexport var mountedInstances = [];\n\nfunction requestLegacyUserMediaAsync(_x) {\n  return _requestLegacyUserMediaAsync.apply(this, arguments);\n}\n\nfunction _requestLegacyUserMediaAsync() {\n  _requestLegacyUserMediaAsync = _asyncToGenerator(function* (props) {\n    var optionalSource = function optionalSource(id) {\n      return {\n        optional: [{\n          sourceId: id\n        }]\n      };\n    };\n\n    var constraintToSourceId = function constraintToSourceId(constraint) {\n      var deviceId = constraint.deviceId;\n\n      if (typeof deviceId === 'string') {\n        return deviceId;\n      }\n\n      if (Array.isArray(deviceId) && deviceId.length > 0) {\n        return deviceId[0];\n      }\n\n      if (typeof deviceId === 'object' && deviceId.ideal) {\n        return deviceId.ideal;\n      }\n\n      return null;\n    };\n\n    var sources = yield new Promise(function (resolve) {\n      return MediaStreamTrack.getSources(function (sources) {\n        return resolve(sources);\n      });\n    });\n    var audioSource = null;\n    var videoSource = null;\n    sources.forEach(function (source) {\n      if (source.kind === 'audio') {\n        audioSource = source.id;\n      } else if (source.kind === 'video') {\n        videoSource = source.id;\n      }\n    });\n    var audioSourceId = constraintToSourceId(props.audioConstraints);\n\n    if (audioSourceId) {\n      audioSource = audioSourceId;\n    }\n\n    var videoSourceId = constraintToSourceId(props.videoConstraints);\n\n    if (videoSourceId) {\n      videoSource = videoSourceId;\n    }\n\n    return [optionalSource(audioSource), optionalSource(videoSource)];\n  });\n  return _requestLegacyUserMediaAsync.apply(this, arguments);\n}\n\nfunction sourceSelectedAsync(_x2, _x3, _x4) {\n  return _sourceSelectedAsync.apply(this, arguments);\n}\n\nfunction _sourceSelectedAsync() {\n  _sourceSelectedAsync = _asyncToGenerator(function* (isMuted, audioConstraints, videoConstraints) {\n    var constraints = {\n      video: typeof videoConstraints !== 'undefined' ? videoConstraints : true\n    };\n\n    if (!isMuted) {\n      constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n    }\n\n    return yield getAnyUserMediaAsync(constraints);\n  });\n  return _sourceSelectedAsync.apply(this, arguments);\n}\n\nexport function requestUserMediaAsync(_x5) {\n  return _requestUserMediaAsync.apply(this, arguments);\n}\n\nfunction _requestUserMediaAsync() {\n  _requestUserMediaAsync = _asyncToGenerator(function* (props) {\n    var isMuted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (canGetUserMedia()) {\n      return yield sourceSelectedAsync(isMuted, props.audio, props.video);\n    }\n\n    var _yield$requestLegacyU = yield requestLegacyUserMediaAsync(props),\n        _yield$requestLegacyU2 = _slicedToArray(_yield$requestLegacyU, 2),\n        audio = _yield$requestLegacyU2[0],\n        video = _yield$requestLegacyU2[1];\n\n    return yield sourceSelectedAsync(isMuted, audio, video);\n  });\n  return _requestUserMediaAsync.apply(this, arguments);\n}\n\nexport function getAnyUserMediaAsync(_x6) {\n  return _getAnyUserMediaAsync.apply(this, arguments);\n}\n\nfunction _getAnyUserMediaAsync() {\n  _getAnyUserMediaAsync = _asyncToGenerator(function* (constraints) {\n    var ignoreConstraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    try {\n      return yield getUserMediaAsync(_objectSpread(_objectSpread({}, constraints), {}, {\n        video: ignoreConstraints || constraints.video\n      }));\n    } catch (error) {\n      if (!ignoreConstraints && error.name === 'ConstraintNotSatisfiedError') {\n        return yield getAnyUserMediaAsync(constraints, true);\n      }\n\n      throw error;\n    }\n  });\n  return _getAnyUserMediaAsync.apply(this, arguments);\n}\n\nexport function getUserMediaAsync(_x7) {\n  return _getUserMediaAsync.apply(this, arguments);\n}\n\nfunction _getUserMediaAsync() {\n  _getUserMediaAsync = _asyncToGenerator(function* (constraints) {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      return navigator.mediaDevices.getUserMedia(constraints);\n    }\n\n    var _getUserMedia = navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'];\n\n    return new Promise(function (resolve, reject) {\n      return _getUserMedia.call(navigator, constraints, resolve, reject);\n    });\n  });\n  return _getUserMediaAsync.apply(this, arguments);\n}\n\nexport function canGetUserMedia() {\n  return Platform.isDOMAvailable && !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia || navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia']);\n}\nexport function isFrontCameraAvailableAsync(_x8) {\n  return _isFrontCameraAvailableAsync.apply(this, arguments);\n}\n\nfunction _isFrontCameraAvailableAsync() {\n  _isFrontCameraAvailableAsync = _asyncToGenerator(function* (devices) {\n    return yield supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n  });\n  return _isFrontCameraAvailableAsync.apply(this, arguments);\n}\n\nexport function isBackCameraAvailableAsync(_x9) {\n  return _isBackCameraAvailableAsync.apply(this, arguments);\n}\n\nfunction _isBackCameraAvailableAsync() {\n  _isBackCameraAvailableAsync = _asyncToGenerator(function* (devices) {\n    return yield supportsCameraType(['back', 'rear'], 'environment', devices);\n  });\n  return _isBackCameraAvailableAsync.apply(this, arguments);\n}\n\nfunction supportsCameraType(_x10, _x11, _x12) {\n  return _supportsCameraType.apply(this, arguments);\n}\n\nfunction _supportsCameraType() {\n  _supportsCameraType = _asyncToGenerator(function* (labels, type, devices) {\n    if (!devices) {\n      if (!navigator.mediaDevices.enumerateDevices) {\n        return null;\n      }\n\n      devices = yield navigator.mediaDevices.enumerateDevices();\n    }\n\n    var cameras = devices.filter(function (t) {\n      return t.kind === 'videoinput';\n    });\n\n    var _cameras$filter = cameras.filter(function (camera) {\n      return labels.some(function (label) {\n        return camera.label.toLowerCase().includes(label);\n      });\n    }),\n        _cameras$filter2 = _slicedToArray(_cameras$filter, 1),\n        hasCamera = _cameras$filter2[0];\n\n    var _cameras$filter3 = cameras.filter(function (camera) {\n      if (!('getCapabilities' in camera)) {\n        return null;\n      }\n\n      var capabilities = camera.getCapabilities();\n\n      if (!capabilities.facingMode) {\n        return null;\n      }\n\n      return capabilities.facingMode.find(function (_) {\n        return type;\n      });\n    }),\n        _cameras$filter4 = _slicedToArray(_cameras$filter3, 1),\n        isCapable = _cameras$filter4[0];\n\n    return (isCapable == null ? void 0 : isCapable.deviceId) || (hasCamera == null ? void 0 : hasCamera.deviceId) || null;\n  });\n  return _supportsCameraType.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["Platform","userMediaRequested","mountedInstances","requestLegacyUserMediaAsync","props","optionalSource","id","optional","sourceId","constraintToSourceId","constraint","deviceId","Array","isArray","length","ideal","sources","Promise","resolve","MediaStreamTrack","getSources","audioSource","videoSource","forEach","source","kind","audioSourceId","audioConstraints","videoSourceId","videoConstraints","sourceSelectedAsync","isMuted","constraints","video","audio","getAnyUserMediaAsync","requestUserMediaAsync","canGetUserMedia","ignoreConstraints","getUserMediaAsync","error","name","navigator","mediaDevices","getUserMedia","_getUserMedia","reject","call","isDOMAvailable","isFrontCameraAvailableAsync","devices","supportsCameraType","isBackCameraAvailableAsync","labels","type","enumerateDevices","cameras","filter","t","camera","some","label","toLowerCase","includes","hasCamera","capabilities","getCapabilities","facingMode","find","_","isCapable"],"sourceRoot":"","sources":["../src/WebUserMediaManager.ts"],"sourcesContent":["/* eslint-env browser */\n/**\n * A web-only module for ponyfilling the UserMedia API.\n */\nimport { Platform } from 'expo-modules-core';\n\nexport const userMediaRequested: boolean = false;\n\nexport const mountedInstances: any[] = [];\n\nasync function requestLegacyUserMediaAsync(props): Promise<any[]> {\n  const optionalSource = (id) => ({ optional: [{ sourceId: id }] });\n\n  const constraintToSourceId = (constraint) => {\n    const { deviceId } = constraint;\n\n    if (typeof deviceId === 'string') {\n      return deviceId;\n    }\n\n    if (Array.isArray(deviceId) && deviceId.length > 0) {\n      return deviceId[0];\n    }\n\n    if (typeof deviceId === 'object' && deviceId.ideal) {\n      return deviceId.ideal;\n    }\n\n    return null;\n  };\n\n  const sources: any[] = await new Promise((resolve) =>\n    // @ts-ignore: https://caniuse.com/#search=getSources Chrome for Android (78) & Samsung Internet (10.1) use this\n    MediaStreamTrack.getSources((sources) => resolve(sources))\n  );\n\n  let audioSource = null;\n  let videoSource = null;\n\n  sources.forEach((source) => {\n    if (source.kind === 'audio') {\n      audioSource = source.id;\n    } else if (source.kind === 'video') {\n      videoSource = source.id;\n    }\n  });\n\n  const audioSourceId = constraintToSourceId(props.audioConstraints);\n  if (audioSourceId) {\n    audioSource = audioSourceId;\n  }\n\n  const videoSourceId = constraintToSourceId(props.videoConstraints);\n  if (videoSourceId) {\n    videoSource = videoSourceId;\n  }\n\n  return [optionalSource(audioSource), optionalSource(videoSource)];\n}\n\nasync function sourceSelectedAsync(\n  isMuted: boolean,\n  audioConstraints?: MediaTrackConstraints | boolean,\n  videoConstraints?: MediaTrackConstraints | boolean\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = {\n    video: typeof videoConstraints !== 'undefined' ? videoConstraints : true,\n  };\n\n  if (!isMuted) {\n    constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n  }\n\n  return await getAnyUserMediaAsync(constraints);\n}\n\nexport async function requestUserMediaAsync(\n  props: { audio?: any; video?: any },\n  isMuted: boolean = true\n): Promise<MediaStream> {\n  if (canGetUserMedia()) {\n    return await sourceSelectedAsync(isMuted, props.audio, props.video);\n  }\n  const [audio, video] = await requestLegacyUserMediaAsync(props);\n  return await sourceSelectedAsync(isMuted, audio, video);\n}\n\nexport async function getAnyUserMediaAsync(\n  constraints: MediaStreamConstraints,\n  ignoreConstraints: boolean = false\n): Promise<MediaStream> {\n  try {\n    return await getUserMediaAsync({\n      ...constraints,\n      video: ignoreConstraints || constraints.video,\n    });\n  } catch (error) {\n    if (!ignoreConstraints && error.name === 'ConstraintNotSatisfiedError') {\n      return await getAnyUserMediaAsync(constraints, true);\n    }\n    throw error;\n  }\n}\n\nexport async function getUserMediaAsync(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  const _getUserMedia =\n    navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'];\n  return new Promise((resolve, reject) =>\n    _getUserMedia.call(navigator, constraints, resolve, reject)\n  );\n}\n\nexport function canGetUserMedia(): boolean {\n  return (\n    // SSR\n    Platform.isDOMAvailable &&\n    // Has any form of media API\n    !!(\n      (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ||\n      navigator['mozGetUserMedia'] ||\n      navigator['webkitGetUserMedia'] ||\n      navigator['msGetUserMedia']\n    )\n  );\n}\n\nexport async function isFrontCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n}\n\nexport async function isBackCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['back', 'rear'], 'environment', devices);\n}\n\nasync function supportsCameraType(\n  labels: string[],\n  type: string,\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  if (!devices) {\n    if (!navigator.mediaDevices.enumerateDevices) {\n      return null;\n    }\n    devices = await navigator.mediaDevices.enumerateDevices();\n  }\n  const cameras = devices.filter((t) => t.kind === 'videoinput');\n  const [hasCamera] = cameras.filter((camera) =>\n    labels.some((label) => camera.label.toLowerCase().includes(label))\n  );\n  const [isCapable] = cameras.filter((camera) => {\n    if (!('getCapabilities' in camera)) {\n      return null;\n    }\n\n    const capabilities = (camera as any).getCapabilities();\n    if (!capabilities.facingMode) {\n      return null;\n    }\n\n    return capabilities.facingMode.find((_: string) => type);\n  });\n\n  return isCapable?.deviceId || hasCamera?.deviceId || null;\n}\n"]},"metadata":{},"sourceType":"module"}