{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"type\", \"pictureSize\", \"poster\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { CodedError } from 'expo-modules-core';\nimport * as React from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport createElement from 'react-native-web/dist/exports/createElement';\nimport { CameraType } from \"./Camera.types\";\nimport CameraManager from \"./ExponentCameraManager.web\";\nimport { capture } from \"./WebCameraUtils\";\nimport { PictureSizes } from \"./WebConstants\";\nimport { useWebCameraStream } from \"./useWebCameraStream\";\nimport { useWebQRScanner } from \"./useWebQRScanner\";\nvar ExponentCamera = React.forwardRef(function (_ref, ref) {\n  var _props$barCodeScanner3, _props$barCodeScanner4;\n\n  var type = _ref.type,\n      pictureSize = _ref.pictureSize,\n      poster = _ref.poster,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  var video = React.useRef(null);\n  var native = useWebCameraStream(video, type, props, {\n    onCameraReady: function onCameraReady() {\n      if (props.onCameraReady) {\n        props.onCameraReady();\n      }\n    },\n    onMountError: props.onMountError\n  });\n  var isQRScannerEnabled = React.useMemo(function () {\n    var _props$barCodeScanner, _props$barCodeScanner2;\n\n    return !!((_props$barCodeScanner = props.barCodeScannerSettings) != null && (_props$barCodeScanner2 = _props$barCodeScanner.barCodeTypes) != null && _props$barCodeScanner2.includes('qr') && !!props.onBarCodeScanned);\n  }, [(_props$barCodeScanner3 = props.barCodeScannerSettings) == null ? void 0 : _props$barCodeScanner3.barCodeTypes, props.onBarCodeScanned]);\n  useWebQRScanner(video, {\n    interval: (_props$barCodeScanner4 = props.barCodeScannerSettings) == null ? void 0 : _props$barCodeScanner4.interval,\n    isEnabled: isQRScannerEnabled,\n    captureOptions: {\n      scale: 1,\n      isImageMirror: native.type === CameraType.front\n    },\n    onScanned: function onScanned(event) {\n      if (props.onBarCodeScanned) {\n        props.onBarCodeScanned(event);\n      }\n    }\n  });\n  React.useImperativeHandle(ref, function () {\n    return {\n      getAvailablePictureSizes: function () {\n        var _getAvailablePictureSizes = _asyncToGenerator(function* (ratio) {\n          return PictureSizes;\n        });\n\n        function getAvailablePictureSizes(_x) {\n          return _getAvailablePictureSizes.apply(this, arguments);\n        }\n\n        return getAvailablePictureSizes;\n      }(),\n      takePicture: function () {\n        var _takePicture = _asyncToGenerator(function* (options) {\n          var _video$current, _video$current2;\n\n          if (!video.current || ((_video$current = video.current) == null ? void 0 : _video$current.readyState) !== ((_video$current2 = video.current) == null ? void 0 : _video$current2.HAVE_ENOUGH_DATA)) {\n            throw new CodedError('ERR_CAMERA_NOT_READY', 'HTMLVideoElement does not have enough camera data to construct an image yet.');\n          }\n\n          var settings = native.mediaTrackSettings;\n\n          if (!settings) {\n            throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n          }\n\n          return capture(video.current, settings, _objectSpread(_objectSpread({}, options), {}, {\n            onPictureSaved: function onPictureSaved(picture) {\n              if (options.onPictureSaved) {\n                options.onPictureSaved(picture);\n              }\n\n              if (props.onPictureSaved) {\n                props.onPictureSaved({\n                  nativeEvent: {\n                    data: picture,\n                    id: -1\n                  }\n                });\n              }\n            }\n          }));\n        });\n\n        function takePicture(_x2) {\n          return _takePicture.apply(this, arguments);\n        }\n\n        return takePicture;\n      }(),\n      resumePreview: function () {\n        var _resumePreview = _asyncToGenerator(function* () {\n          if (video.current) {\n            video.current.play();\n          }\n        });\n\n        function resumePreview() {\n          return _resumePreview.apply(this, arguments);\n        }\n\n        return resumePreview;\n      }(),\n      pausePreview: function () {\n        var _pausePreview = _asyncToGenerator(function* () {\n          if (video.current) {\n            video.current.pause();\n          }\n        });\n\n        function pausePreview() {\n          return _pausePreview.apply(this, arguments);\n        }\n\n        return pausePreview;\n      }()\n    };\n  }, [native.mediaTrackSettings, props.onPictureSaved]);\n  var isMuted = true;\n  var style = React.useMemo(function () {\n    var isFrontFacingCamera = native.type === CameraManager.Type.front;\n    return [StyleSheet.absoluteFill, styles.video, {\n      transform: isFrontFacingCamera ? [{\n        scaleX: -1\n      }] : undefined\n    }];\n  }, [native.type]);\n  return React.createElement(View, {\n    pointerEvents: \"box-none\",\n    style: [styles.videoWrapper, props.style]\n  }, React.createElement(Video, {\n    autoPlay: true,\n    playsInline: true,\n    muted: isMuted,\n    poster: poster,\n    pointerEvents: props.pointerEvents,\n    ref: video,\n    style: style\n  }), props.children);\n});\nexport default ExponentCamera;\nvar Video = React.forwardRef(function (props, ref) {\n  return createElement('video', _objectSpread(_objectSpread({}, props), {}, {\n    ref: ref\n  }));\n});\nvar styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch'\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover'\n  }\n});","map":{"version":3,"mappings":"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","names":["CodedError","React","createElement","CameraType","CameraManager","capture","PictureSizes","useWebCameraStream","useWebQRScanner","ExponentCamera","forwardRef","ref","type","pictureSize","poster","props","video","useRef","native","onCameraReady","onMountError","isQRScannerEnabled","useMemo","barCodeScannerSettings","barCodeTypes","includes","onBarCodeScanned","interval","isEnabled","captureOptions","scale","isImageMirror","front","onScanned","event","useImperativeHandle","getAvailablePictureSizes","ratio","takePicture","options","current","readyState","HAVE_ENOUGH_DATA","settings","mediaTrackSettings","onPictureSaved","picture","nativeEvent","data","id","resumePreview","play","pausePreview","pause","isMuted","style","isFrontFacingCamera","Type","StyleSheet","absoluteFill","styles","transform","scaleX","undefined","View","pointerEvents","videoWrapper","Video","autoPlay","playsInline","muted","children","create","flex","alignItems","width","height","objectFit"],"sourceRoot":"","sources":["../src/ExponentCamera.web.tsx"],"sourcesContent":["import { CodedError } from 'expo-modules-core';\nimport * as React from 'react';\nimport { StyleProp, StyleSheet, View, ViewStyle } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\n\nimport {\n  CameraCapturedPicture,\n  CameraNativeProps,\n  CameraPictureOptions,\n  CameraType,\n} from './Camera.types';\nimport CameraManager from './ExponentCameraManager.web';\nimport { capture } from './WebCameraUtils';\nimport { PictureSizes } from './WebConstants';\nimport { useWebCameraStream } from './useWebCameraStream';\nimport { useWebQRScanner } from './useWebQRScanner';\n\nexport interface ExponentCameraRef {\n  getAvailablePictureSizes: (ratio: string) => Promise<string[]>;\n  takePicture: (options: CameraPictureOptions) => Promise<CameraCapturedPicture>;\n  resumePreview: () => Promise<void>;\n  pausePreview: () => Promise<void>;\n}\n\nconst ExponentCamera = React.forwardRef(\n  (\n    { type, pictureSize, poster, ...props }: CameraNativeProps & { children?: React.ReactNode },\n    ref: React.Ref<ExponentCameraRef>\n  ) => {\n    const video = React.useRef<HTMLVideoElement | null>(null);\n\n    const native = useWebCameraStream(video, type as CameraType, props, {\n      onCameraReady() {\n        if (props.onCameraReady) {\n          props.onCameraReady();\n        }\n      },\n      onMountError: props.onMountError,\n    });\n\n    const isQRScannerEnabled = React.useMemo<boolean>(() => {\n      return !!(\n        props.barCodeScannerSettings?.barCodeTypes?.includes('qr') && !!props.onBarCodeScanned\n      );\n    }, [props.barCodeScannerSettings?.barCodeTypes, props.onBarCodeScanned]);\n\n    useWebQRScanner(video, {\n      interval: props.barCodeScannerSettings?.interval,\n      isEnabled: isQRScannerEnabled,\n      captureOptions: { scale: 1, isImageMirror: native.type === CameraType.front },\n      onScanned(event) {\n        if (props.onBarCodeScanned) {\n          props.onBarCodeScanned(event);\n        }\n      },\n      // onError: props.onMountError,\n    });\n\n    // const [pause, setPaused]\n\n    React.useImperativeHandle(\n      ref,\n      () => ({\n        async getAvailablePictureSizes(ratio: string): Promise<string[]> {\n          return PictureSizes;\n        },\n        async takePicture(options: CameraPictureOptions): Promise<CameraCapturedPicture> {\n          if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n            throw new CodedError(\n              'ERR_CAMERA_NOT_READY',\n              'HTMLVideoElement does not have enough camera data to construct an image yet.'\n            );\n          }\n          const settings = native.mediaTrackSettings;\n          if (!settings) {\n            throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n          }\n\n          return capture(video.current, settings, {\n            ...options,\n            // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n            onPictureSaved(picture) {\n              if (options.onPictureSaved) {\n                options.onPictureSaved(picture);\n              }\n              if (props.onPictureSaved) {\n                props.onPictureSaved({ nativeEvent: { data: picture, id: -1 } });\n              }\n            },\n          });\n        },\n        async resumePreview(): Promise<void> {\n          if (video.current) {\n            video.current.play();\n          }\n        },\n        async pausePreview(): Promise<void> {\n          if (video.current) {\n            video.current.pause();\n          }\n        },\n      }),\n      [native.mediaTrackSettings, props.onPictureSaved]\n    );\n\n    // TODO(Bacon): Create a universal prop, on native the microphone is only used when recording videos.\n    // Because we don't support recording video in the browser we don't need the user to give microphone permissions.\n    const isMuted = true;\n\n    const style = React.useMemo<StyleProp<ViewStyle>>(() => {\n      const isFrontFacingCamera = native.type === CameraManager.Type.front;\n      return [\n        StyleSheet.absoluteFill,\n        styles.video,\n        {\n          // Flip the camera\n          transform: isFrontFacingCamera ? [{ scaleX: -1 }] : undefined,\n        },\n      ];\n    }, [native.type]);\n\n    return (\n      <View pointerEvents=\"box-none\" style={[styles.videoWrapper, props.style]}>\n        <Video\n          autoPlay\n          playsInline\n          muted={isMuted}\n          poster={poster}\n          // webkitPlaysinline\n          pointerEvents={props.pointerEvents}\n          ref={video}\n          style={style}\n        />\n        {props.children}\n      </View>\n    );\n  }\n);\n\nexport default ExponentCamera;\n\nconst Video = React.forwardRef(\n  (\n    props: React.ComponentProps<typeof View> & {\n      autoPlay?: boolean;\n      playsInline?: boolean;\n      muted?: boolean;\n      poster?: string;\n    },\n    ref: React.Ref<HTMLVideoElement>\n  ) => createElement('video', { ...props, ref })\n);\n\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch',\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover',\n  },\n});\n"]},"metadata":{},"sourceType":"module"}