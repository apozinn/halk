{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport invariant from 'invariant';\nimport { CameraType, ImageType } from \"./Camera.types\";\nimport * as CapabilityUtils from \"./WebCapabilityUtils\";\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from \"./WebConstants\";\nimport { requestUserMediaAsync } from \"./WebUserMediaManager\";\nexport function getImageSize(videoWidth, videoHeight, scale) {\n  var width = videoWidth * scale;\n  var ratio = videoWidth / width;\n  var height = videoHeight / ratio;\n  return {\n    width: width,\n    height: height\n  };\n}\nexport function toDataURL(canvas, imageType, quality) {\n  invariant(Object.values(ImageType).includes(imageType), \"expo-camera: \" + imageType + \" is not a valid ImageType. Expected a string from: \" + Object.values(ImageType).join(', '));\n  var format = ImageTypeFormat[imageType];\n\n  if (imageType === ImageType.jpg) {\n    invariant(quality <= 1 && quality >= 0, \"expo-camera: \" + quality + \" is not a valid image quality. Expected a number from 0...1\");\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\nexport function hasValidConstraints(preferredCameraType, width, height) {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\n\nfunction ensureCameraPictureOptions(config) {\n  var captureOptions = {\n    scale: 1,\n    imageType: ImageType.png,\n    isImageMirror: false\n  };\n\n  for (var key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n\n  return captureOptions;\n}\n\nvar DEFAULT_QUALITY = 0.92;\nexport function captureImageData(video) {\n  var pictureOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n\n  var canvas = captureImageContext(video, pictureOptions);\n  var context = canvas.getContext('2d', {\n    alpha: false\n  });\n\n  if (!context || !canvas.width || !canvas.height) {\n    return null;\n  }\n\n  var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  return imageData;\n}\nexport function captureImageContext(video, _ref) {\n  var _ref$scale = _ref.scale,\n      scale = _ref$scale === void 0 ? 1 : _ref$scale,\n      _ref$isImageMirror = _ref.isImageMirror,\n      isImageMirror = _ref$isImageMirror === void 0 ? false : _ref$isImageMirror;\n  var videoWidth = video.videoWidth,\n      videoHeight = video.videoHeight;\n\n  var _getImageSize = getImageSize(videoWidth, videoHeight, scale),\n      width = _getImageSize.width,\n      height = _getImageSize.height;\n\n  var canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  var context = canvas.getContext('2d', {\n    alpha: false\n  });\n\n  if (!context) {\n    throw new Error('Context is not defined');\n  }\n\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n\n  context.drawImage(video, 0, 0, width, height);\n  return canvas;\n}\nexport function captureImage(video, pictureOptions) {\n  var config = ensureCameraPictureOptions(pictureOptions);\n  var canvas = captureImageContext(video, config);\n  var imageType = config.imageType,\n      _config$quality = config.quality,\n      quality = _config$quality === void 0 ? DEFAULT_QUALITY : _config$quality;\n  return toDataURL(canvas, imageType, quality);\n}\n\nfunction getSupportedConstraints() {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n\n  return null;\n}\n\nexport function getIdealConstraints(preferredCameraType, width, height) {\n  var preferredConstraints = {\n    audio: false,\n    video: {}\n  };\n\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n\n  var supports = getSupportedConstraints();\n\n  if (!supports || !supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n\n  if (preferredCameraType && Object.values(CameraType).includes(preferredCameraType)) {\n    var facingMode = CameraTypeToFacingMode[preferredCameraType];\n\n    if (isWebKit()) {\n      var key = facingMode === 'user' ? 'exact' : 'ideal';\n      preferredConstraints.video.facingMode = _defineProperty({}, key, facingMode);\n    } else {\n      preferredConstraints.video.facingMode = {\n        ideal: CameraTypeToFacingMode[preferredCameraType]\n      };\n    }\n  }\n\n  if (isMediaTrackConstraints(preferredConstraints.video)) {\n    preferredConstraints.video.width = width;\n    preferredConstraints.video.height = height;\n  }\n\n  return preferredConstraints;\n}\n\nfunction isMediaTrackConstraints(input) {\n  return input && typeof input.video !== 'boolean';\n}\n\nexport function getPreferredStreamDevice(_x, _x2, _x3) {\n  return _getPreferredStreamDevice.apply(this, arguments);\n}\n\nfunction _getPreferredStreamDevice() {\n  _getPreferredStreamDevice = _asyncToGenerator(function* (preferredCameraType, preferredWidth, preferredHeight) {\n    try {\n      return yield getStreamDevice(preferredCameraType, preferredWidth, preferredHeight);\n    } catch (error) {\n      if (error instanceof OverconstrainedError && error.constraint === 'facingMode') {\n        var nextCameraType = preferredCameraType === CameraType.back ? CameraType.front : CameraType.back;\n        return yield getStreamDevice(nextCameraType, preferredWidth, preferredHeight);\n      }\n\n      throw error;\n    }\n  });\n  return _getPreferredStreamDevice.apply(this, arguments);\n}\n\nexport function getStreamDevice(_x4, _x5, _x6) {\n  return _getStreamDevice.apply(this, arguments);\n}\n\nfunction _getStreamDevice() {\n  _getStreamDevice = _asyncToGenerator(function* (preferredCameraType, preferredWidth, preferredHeight) {\n    var constraints = getIdealConstraints(preferredCameraType, preferredWidth, preferredHeight);\n    var stream = yield requestUserMediaAsync(constraints);\n    return stream;\n  });\n  return _getStreamDevice.apply(this, arguments);\n}\n\nexport function isWebKit() {\n  return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);\n}\nexport function compareStreams(a, b) {\n  if (!a || !b) {\n    return false;\n  }\n\n  var settingsA = a.getTracks()[0].getSettings();\n  var settingsB = b.getTracks()[0].getSettings();\n  return settingsA.deviceId === settingsB.deviceId;\n}\nexport function capture(video, settings, config) {\n  var base64 = captureImage(video, config);\n  var capturedPicture = {\n    uri: base64,\n    base64: base64,\n    width: 0,\n    height: 0\n  };\n\n  if (settings) {\n    var _settings$width = settings.width,\n        width = _settings$width === void 0 ? 0 : _settings$width,\n        _settings$height = settings.height,\n        height = _settings$height === void 0 ? 0 : _settings$height;\n    capturedPicture.width = width;\n    capturedPicture.height = height;\n    capturedPicture.exif = settings;\n  }\n\n  if (config.onPictureSaved) {\n    config.onPictureSaved(capturedPicture);\n  }\n\n  return capturedPicture;\n}\nexport function syncTrackCapabilities(_x7, _x8) {\n  return _syncTrackCapabilities.apply(this, arguments);\n}\n\nfunction _syncTrackCapabilities() {\n  _syncTrackCapabilities = _asyncToGenerator(function* (cameraType, stream) {\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (stream != null && stream.getVideoTracks) {\n      yield Promise.all(stream.getVideoTracks().map(function (track) {\n        return onCapabilitiesReady(cameraType, track, settings);\n      }));\n    }\n  });\n  return _syncTrackCapabilities.apply(this, arguments);\n}\n\nfunction onCapabilitiesReady(_x9, _x10) {\n  return _onCapabilitiesReady.apply(this, arguments);\n}\n\nfunction _onCapabilitiesReady() {\n  _onCapabilitiesReady = _asyncToGenerator(function* (cameraType, track) {\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var capabilities = track.getCapabilities();\n    var constraints = {};\n    var clampedValues = ['exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'zoom'];\n\n    for (var property of clampedValues) {\n      if (capabilities[property]) {\n        constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n      }\n    }\n\n    function validatedInternalConstrainedValue(constraintKey, settingsKey, converter) {\n      var convertedSetting = converter(settings[settingsKey]);\n      return validatedConstrainedValue({\n        constraintKey: constraintKey,\n        settingsKey: settingsKey,\n        convertedSetting: convertedSetting,\n        capabilities: capabilities,\n        settings: settings,\n        cameraType: cameraType\n      });\n    }\n\n    if (capabilities.focusMode && settings.autoFocus !== undefined) {\n      constraints.focusMode = validatedInternalConstrainedValue('focusMode', 'autoFocus', CapabilityUtils.convertAutoFocusJSONToNative);\n    }\n\n    if (capabilities.torch && settings.flashMode !== undefined) {\n      constraints.torch = validatedInternalConstrainedValue('torch', 'flashMode', CapabilityUtils.convertFlashModeJSONToNative);\n    }\n\n    if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n      constraints.whiteBalanceMode = validatedInternalConstrainedValue('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n    }\n\n    try {\n      yield track.applyConstraints({\n        advanced: [constraints]\n      });\n    } catch (error) {\n      if (__DEV__) console.warn('Failed to apply constraints', error);\n    }\n  });\n  return _onCapabilitiesReady.apply(this, arguments);\n}\n\nexport function stopMediaStream(stream) {\n  if (!stream) {\n    return;\n  }\n\n  if (stream.getAudioTracks) {\n    stream.getAudioTracks().forEach(function (track) {\n      return track.stop();\n    });\n  }\n\n  if (stream.getVideoTracks) {\n    stream.getVideoTracks().forEach(function (track) {\n      return track.stop();\n    });\n  }\n\n  if (isMediaStreamTrack(stream)) {\n    stream.stop();\n  }\n}\nexport function setVideoSource(video, stream) {\n  var _window$URL$createObj;\n\n  var createObjectURL = (_window$URL$createObj = window.URL.createObjectURL) != null ? _window$URL$createObj : window.webkitURL.createObjectURL;\n\n  if (typeof video.srcObject !== 'undefined') {\n    video.srcObject = stream;\n  } else if (typeof video.mozSrcObject !== 'undefined') {\n    video.mozSrcObject = stream;\n  } else if (stream && createObjectURL) {\n    video.src = createObjectURL(stream);\n  }\n\n  if (!stream) {\n    var _window$URL$revokeObj, _ref2, _video$src;\n\n    var revokeObjectURL = (_window$URL$revokeObj = window.URL.revokeObjectURL) != null ? _window$URL$revokeObj : window.webkitURL.revokeObjectURL;\n    var source = (_ref2 = (_video$src = video.src) != null ? _video$src : video.srcObject) != null ? _ref2 : video.mozSrcObject;\n\n    if (revokeObjectURL && typeof source === 'string') {\n      revokeObjectURL(source);\n    }\n  }\n}\nexport function isCapabilityAvailable(video, keyName) {\n  var stream = video.srcObject;\n\n  if (stream instanceof MediaStream) {\n    var _videoTrack$getCapabi;\n\n    var videoTrack = stream.getVideoTracks()[0];\n    return videoTrack.getCapabilities == null ? void 0 : (_videoTrack$getCapabi = videoTrack.getCapabilities()) == null ? void 0 : _videoTrack$getCapabi[keyName];\n  }\n\n  return false;\n}\n\nfunction isMediaStreamTrack(input) {\n  return typeof input.stop === 'function';\n}\n\nfunction convertNormalizedSetting(range, value) {\n  if (!value) {\n    return;\n  }\n\n  var converted = convertRange(value, [range.min, range.max]);\n  return Math.min(range.max, Math.max(range.min, converted));\n}\n\nfunction convertRange(value, r2) {\n  var r1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 1];\n  return (value - r1[0]) * (r2[1] - r2[0]) / (r1[1] - r1[0]) + r2[0];\n}\n\nfunction validatedConstrainedValue(props) {\n  var constraintKey = props.constraintKey,\n      settingsKey = props.settingsKey,\n      convertedSetting = props.convertedSetting,\n      capabilities = props.capabilities,\n      settings = props.settings,\n      cameraType = props.cameraType;\n  var setting = settings[settingsKey];\n\n  if (Array.isArray(capabilities[constraintKey]) && convertedSetting && !capabilities[constraintKey].includes(convertedSetting)) {\n    if (__DEV__) {\n      console.warn(\" { \" + settingsKey + \": \\\"\" + setting + \"\\\" } (converted to \\\"\" + convertedSetting + \"\\\" in the browser) is not supported for camera type \\\"\" + cameraType + \"\\\" in your browser. Using the default value instead.\");\n    }\n\n    return undefined;\n  }\n\n  return convertedSetting;\n}","map":{"version":3,"mappings":"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","names":["invariant","CameraType","ImageType","CapabilityUtils","CameraTypeToFacingMode","ImageTypeFormat","MinimumConstraints","requestUserMediaAsync","getImageSize","videoWidth","videoHeight","scale","width","ratio","height","toDataURL","canvas","imageType","quality","Object","values","includes","join","format","jpg","hasValidConstraints","preferredCameraType","undefined","ensureCameraPictureOptions","config","captureOptions","png","isImageMirror","key","DEFAULT_QUALITY","captureImageData","video","pictureOptions","readyState","HAVE_ENOUGH_DATA","captureImageContext","context","getContext","alpha","imageData","getImageData","document","createElement","Error","setTransform","drawImage","captureImage","getSupportedConstraints","navigator","mediaDevices","getIdealConstraints","preferredConstraints","audio","supports","facingMode","isWebKit","ideal","isMediaTrackConstraints","input","getPreferredStreamDevice","preferredWidth","preferredHeight","getStreamDevice","error","OverconstrainedError","constraint","nextCameraType","back","front","constraints","stream","test","userAgent","compareStreams","a","b","settingsA","getTracks","getSettings","settingsB","deviceId","capture","settings","base64","capturedPicture","uri","exif","onPictureSaved","syncTrackCapabilities","cameraType","getVideoTracks","Promise","all","map","track","onCapabilitiesReady","capabilities","getCapabilities","clampedValues","property","convertNormalizedSetting","validatedInternalConstrainedValue","constraintKey","settingsKey","converter","convertedSetting","validatedConstrainedValue","focusMode","autoFocus","convertAutoFocusJSONToNative","torch","flashMode","convertFlashModeJSONToNative","whiteBalanceMode","whiteBalance","convertWhiteBalanceJSONToNative","applyConstraints","advanced","__DEV__","console","warn","stopMediaStream","getAudioTracks","forEach","stop","isMediaStreamTrack","setVideoSource","createObjectURL","window","URL","webkitURL","srcObject","mozSrcObject","src","revokeObjectURL","source","isCapabilityAvailable","keyName","MediaStream","videoTrack","range","value","converted","convertRange","min","max","Math","r2","r1","props","setting","Array","isArray"],"sourceRoot":"","sources":["../src/WebCameraUtils.ts"],"sourcesContent":["/* eslint-env browser */\nimport invariant from 'invariant';\n\nimport {\n  CameraType,\n  CameraCapturedPicture,\n  ImageSize,\n  ImageType,\n  WebCameraSettings,\n  CameraPictureOptions,\n} from './Camera.types';\nimport * as CapabilityUtils from './WebCapabilityUtils';\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from './WebConstants';\nimport { requestUserMediaAsync } from './WebUserMediaManager';\n\ninterface ConstrainLongRange {\n  max?: number;\n  min?: number;\n  exact?: number;\n  ideal?: number;\n}\n\nexport function getImageSize(videoWidth: number, videoHeight: number, scale: number): ImageSize {\n  const width = videoWidth * scale;\n  const ratio = videoWidth / width;\n  const height = videoHeight / ratio;\n\n  return {\n    width,\n    height,\n  };\n}\n\nexport function toDataURL(\n  canvas: HTMLCanvasElement,\n  imageType: ImageType,\n  quality: number\n): string {\n  invariant(\n    Object.values(ImageType).includes(imageType),\n    `expo-camera: ${imageType} is not a valid ImageType. Expected a string from: ${Object.values(\n      ImageType\n    ).join(', ')}`\n  );\n\n  const format = ImageTypeFormat[imageType];\n  if (imageType === ImageType.jpg) {\n    invariant(\n      quality <= 1 && quality >= 0,\n      `expo-camera: ${quality} is not a valid image quality. Expected a number from 0...1`\n    );\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\n\nexport function hasValidConstraints(\n  preferredCameraType?: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): boolean {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\n\nfunction ensureCameraPictureOptions(config: CameraPictureOptions): CameraPictureOptions {\n  const captureOptions = {\n    scale: 1,\n    imageType: ImageType.png,\n    isImageMirror: false,\n  };\n\n  for (const key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n  return captureOptions;\n}\n\nconst DEFAULT_QUALITY = 0.92;\n\nexport function captureImageData(\n  video: HTMLVideoElement | null,\n  pictureOptions: Pick<CameraPictureOptions, 'scale' | 'isImageMirror'> = {}\n): ImageData | null {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n  const canvas = captureImageContext(video, pictureOptions);\n\n  const context = canvas.getContext('2d', { alpha: false });\n  if (!context || !canvas.width || !canvas.height) {\n    return null;\n  }\n\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  return imageData;\n}\n\nexport function captureImageContext(\n  video: HTMLVideoElement,\n  { scale = 1, isImageMirror = false }: Pick<CameraPictureOptions, 'scale' | 'isImageMirror'>\n): HTMLCanvasElement {\n  const { videoWidth, videoHeight } = video;\n  const { width, height } = getImageSize(videoWidth, videoHeight, scale!);\n\n  // Build the canvas size and draw the camera image to the context from video\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d', { alpha: false });\n\n  if (!context) {\n    // Should never be called\n    throw new Error('Context is not defined');\n  }\n  // sharp image details\n  // context.imageSmoothingEnabled = false;\n\n  // Flip horizontally (as css transform: rotateY(180deg))\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n\n  context.drawImage(video, 0, 0, width, height);\n\n  return canvas;\n}\n\nexport function captureImage(\n  video: HTMLVideoElement,\n  pictureOptions: CameraPictureOptions\n): string {\n  const config = ensureCameraPictureOptions(pictureOptions);\n  const canvas = captureImageContext(video, config);\n  const { imageType, quality = DEFAULT_QUALITY } = config;\n  return toDataURL(canvas, imageType!, quality);\n}\n\nfunction getSupportedConstraints(): MediaTrackSupportedConstraints | null {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n  return null;\n}\n\nexport function getIdealConstraints(\n  preferredCameraType: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): MediaStreamConstraints {\n  const preferredConstraints: MediaStreamConstraints = {\n    audio: false,\n    video: {},\n  };\n\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n\n  const supports = getSupportedConstraints();\n  // TODO(Bacon): Test this\n  if (!supports || !supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n\n  if (preferredCameraType && Object.values(CameraType).includes(preferredCameraType)) {\n    const facingMode = CameraTypeToFacingMode[preferredCameraType];\n    if (isWebKit()) {\n      const key = facingMode === 'user' ? 'exact' : 'ideal';\n      (preferredConstraints.video as MediaTrackConstraints).facingMode = {\n        [key]: facingMode,\n      };\n    } else {\n      (preferredConstraints.video as MediaTrackConstraints).facingMode = {\n        ideal: CameraTypeToFacingMode[preferredCameraType],\n      };\n    }\n  }\n\n  if (isMediaTrackConstraints(preferredConstraints.video)) {\n    preferredConstraints.video.width = width;\n    preferredConstraints.video.height = height;\n  }\n\n  return preferredConstraints;\n}\n\nfunction isMediaTrackConstraints(input: any): input is MediaTrackConstraints {\n  return input && typeof input.video !== 'boolean';\n}\n\n/**\n * Invoke getStreamDevice a second time with the opposing camera type if the preferred type cannot be retrieved.\n *\n * @param preferredCameraType\n * @param preferredWidth\n * @param preferredHeight\n */\nexport async function getPreferredStreamDevice(\n  preferredCameraType: CameraType,\n  preferredWidth?: number | ConstrainLongRange,\n  preferredHeight?: number | ConstrainLongRange\n): Promise<MediaStream> {\n  try {\n    return await getStreamDevice(preferredCameraType, preferredWidth, preferredHeight);\n  } catch (error) {\n    // A hack on desktop browsers to ensure any camera is used.\n    // eslint-disable-next-line no-undef\n    if (error instanceof OverconstrainedError && error.constraint === 'facingMode') {\n      const nextCameraType =\n        preferredCameraType === CameraType.back ? CameraType.front : CameraType.back;\n      return await getStreamDevice(nextCameraType, preferredWidth, preferredHeight);\n    }\n    throw error;\n  }\n}\n\nexport async function getStreamDevice(\n  preferredCameraType: CameraType,\n  preferredWidth?: number | ConstrainLongRange,\n  preferredHeight?: number | ConstrainLongRange\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = getIdealConstraints(\n    preferredCameraType,\n    preferredWidth,\n    preferredHeight\n  );\n  const stream: MediaStream = await requestUserMediaAsync(constraints);\n  return stream;\n}\n\nexport function isWebKit(): boolean {\n  return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);\n}\n\nexport function compareStreams(a: MediaStream | null, b: MediaStream | null): boolean {\n  if (!a || !b) {\n    return false;\n  }\n  const settingsA = a.getTracks()[0].getSettings();\n  const settingsB = b.getTracks()[0].getSettings();\n  return settingsA.deviceId === settingsB.deviceId;\n}\n\nexport function capture(\n  video: HTMLVideoElement,\n  settings: MediaTrackSettings,\n  config: CameraPictureOptions\n): CameraCapturedPicture {\n  const base64 = captureImage(video, config);\n\n  const capturedPicture: CameraCapturedPicture = {\n    uri: base64,\n    base64,\n    width: 0,\n    height: 0,\n  };\n\n  if (settings) {\n    const { width = 0, height = 0 } = settings;\n    capturedPicture.width = width;\n    capturedPicture.height = height;\n    capturedPicture.exif = settings;\n  }\n\n  if (config.onPictureSaved) {\n    config.onPictureSaved(capturedPicture);\n  }\n  return capturedPicture;\n}\n\nexport async function syncTrackCapabilities(\n  cameraType: CameraType,\n  stream: MediaStream | null,\n  settings: WebCameraSettings = {}\n): Promise<void> {\n  if (stream?.getVideoTracks) {\n    await Promise.all(\n      stream.getVideoTracks().map((track) => onCapabilitiesReady(cameraType, track, settings))\n    );\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\nasync function onCapabilitiesReady(\n  cameraType: CameraType,\n  track: MediaStreamTrack,\n  settings: WebCameraSettings = {}\n): Promise<void> {\n  const capabilities = track.getCapabilities();\n\n  // Create an empty object because if you set a constraint that isn't available an error will be thrown.\n  const constraints: MediaTrackConstraintSet = {};\n\n  // TODO(Bacon): Add `pointsOfInterest` support\n  const clampedValues = [\n    'exposureCompensation',\n    'colorTemperature',\n    'iso',\n    'brightness',\n    'contrast',\n    'saturation',\n    'sharpness',\n    'focusDistance',\n    'zoom',\n  ];\n\n  for (const property of clampedValues) {\n    if (capabilities[property]) {\n      constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n    }\n  }\n\n  function validatedInternalConstrainedValue<IConvertedType>(\n    constraintKey: string,\n    settingsKey: string,\n    converter: (settingValue: any) => IConvertedType\n  ) {\n    const convertedSetting = converter(settings[settingsKey]);\n    return validatedConstrainedValue({\n      constraintKey,\n      settingsKey,\n      convertedSetting,\n      capabilities,\n      settings,\n      cameraType,\n    });\n  }\n\n  if (capabilities.focusMode && settings.autoFocus !== undefined) {\n    constraints.focusMode = validatedInternalConstrainedValue<MediaTrackConstraintSet['focusMode']>(\n      'focusMode',\n      'autoFocus',\n      CapabilityUtils.convertAutoFocusJSONToNative\n    );\n  }\n\n  if (capabilities.torch && settings.flashMode !== undefined) {\n    constraints.torch = validatedInternalConstrainedValue<MediaTrackConstraintSet['torch']>(\n      'torch',\n      'flashMode',\n      CapabilityUtils.convertFlashModeJSONToNative\n    );\n  }\n\n  if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n    constraints.whiteBalanceMode = validatedInternalConstrainedValue<\n      MediaTrackConstraintSet['whiteBalanceMode']\n    >('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n  }\n\n  try {\n    await track.applyConstraints({ advanced: [constraints] });\n  } catch (error) {\n    if (__DEV__) console.warn('Failed to apply constraints', error);\n  }\n}\n\nexport function stopMediaStream(stream: MediaStream | null) {\n  if (!stream) {\n    return;\n  }\n  if (stream.getAudioTracks) {\n    stream.getAudioTracks().forEach((track) => track.stop());\n  }\n  if (stream.getVideoTracks) {\n    stream.getVideoTracks().forEach((track) => track.stop());\n  }\n  if (isMediaStreamTrack(stream)) {\n    stream.stop();\n  }\n}\n\nexport function setVideoSource(\n  video: HTMLVideoElement,\n  stream: MediaStream | MediaSource | Blob | null\n): void {\n  const createObjectURL = window.URL.createObjectURL ?? window.webkitURL.createObjectURL;\n\n  if (typeof video.srcObject !== 'undefined') {\n    video.srcObject = stream;\n  } else if (typeof (video as any).mozSrcObject !== 'undefined') {\n    (video as any).mozSrcObject = stream;\n  } else if (stream && createObjectURL) {\n    video.src = createObjectURL(stream as MediaSource | Blob);\n  }\n\n  if (!stream) {\n    const revokeObjectURL = window.URL.revokeObjectURL ?? window.webkitURL.revokeObjectURL;\n    const source = video.src ?? video.srcObject ?? (video as any).mozSrcObject;\n    if (revokeObjectURL && typeof source === 'string') {\n      revokeObjectURL(source);\n    }\n  }\n}\n\nexport function isCapabilityAvailable(video: HTMLVideoElement, keyName: string): boolean {\n  const stream = video.srcObject;\n\n  if (stream instanceof MediaStream) {\n    const videoTrack = stream.getVideoTracks()[0];\n    return videoTrack.getCapabilities?.()?.[keyName];\n  }\n\n  return false;\n}\n\nfunction isMediaStreamTrack(input: any): input is MediaStreamTrack {\n  return typeof input.stop === 'function';\n}\n\nfunction convertNormalizedSetting(range: MediaSettingsRange, value?: number): number | undefined {\n  if (!value) {\n    return;\n  }\n  // convert the normalized incoming setting to the native camera zoom range\n  const converted = convertRange(value, [range.min, range.max]);\n  // clamp value so we don't get an error\n  return Math.min(range.max, Math.max(range.min, converted));\n}\n\nfunction convertRange(value: number, r2: number[], r1: number[] = [0, 1]): number {\n  return ((value - r1[0]) * (r2[1] - r2[0])) / (r1[1] - r1[0]) + r2[0];\n}\n\nfunction validatedConstrainedValue<T>(props: {\n  constraintKey: string;\n  settingsKey: string;\n  convertedSetting: T;\n  capabilities: MediaTrackCapabilities;\n  settings: WebCameraSettings;\n  cameraType: string;\n}): T | undefined {\n  const { constraintKey, settingsKey, convertedSetting, capabilities, settings, cameraType } =\n    props;\n  const setting = settings[settingsKey];\n  if (\n    Array.isArray(capabilities[constraintKey]) &&\n    convertedSetting &&\n    !capabilities[constraintKey].includes(convertedSetting)\n  ) {\n    if (__DEV__) {\n      // Only warn in dev mode.\n      console.warn(\n        ` { ${settingsKey}: \"${setting}\" } (converted to \"${convertedSetting}\" in the browser) is not supported for camera type \"${cameraType}\" in your browser. Using the default value instead.`\n      );\n    }\n    return undefined;\n  }\n  return convertedSetting;\n}\n"]},"metadata":{},"sourceType":"module"}